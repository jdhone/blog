<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Nick Drane</title>
  <meta name="author" content="Nick Drane">
  
  <meta name="description" content="Nick Drane&#39;s blog about programming and modern web development, particularly Node.js and React.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Nick Drane"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Nick Drane" type="application/atom+xml">

  <link rel="stylesheet" href="/css/style.css"  media="none" onload="if(media!='all')media='all'">
  <noscript><link rel="stylesheet" href="css.css"></noscript>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-107252357-1', 'auto');
		ga('send', 'pageview');

	</script>
	
</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Nick Drane</a></h1>
  <h2><a href="/">Learn Modern Web Development</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/projects">Projects</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/scraping-the-web-with-puppeteer-lessons-learned/">Scraping the Web With Puppeteer: Lessons-learned</a></h1>
  

      
        <time datetime="2017-11-30T18:20:20.000Z">2017-11-30</time>
      
    </header>
    <div class="entry">
      
        <p>I’m currently contracted with <a href="https://www.fraight.ai/" target="_blank" rel="external">Fraight</a> to create a web service using some data from a third party Angular application. I worked off a existing proof of concept codebase that used Chrome’s new <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="external">Puppeteer</a> API to scrape this site. I strongly regret not starting from scratch.</p>
<h2 id="What-is-Puppeteer"><a href="#What-is-Puppeteer" class="headerlink" title="What is Puppeteer?"></a>What is Puppeteer?</h2><p>Puppeteer is a Node API that allows you to control Google’s headless Chrome browser. Imagine a version of your browser that can send and receive requests but has no GUI. It just performs everything in the background, performing actions as instructed by an API. This makes Puppeteer great for end to end testing a web application. You can truly simulate the user experience, typing where they type and clicking where they click. Another use case for Puppeteer is web scraping a Single Page Application or an application where the content is rendered entirely server side. We are going to look at scraping a SPA today.</p>
<h2 id="A-Simple-Example"><a href="#A-Simple-Example" class="headerlink" title="A Simple Example"></a>A Simple Example</h2><p>First you need to create an instance of the headless browser and navigate to a webpage. Perhaps we want to fill out a login form, logging into a website.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch()</div><div class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> <span class="keyword">this</span>.browser.newPage();</div><div class="line"><span class="keyword">await</span> page.goto(<span class="string">"https://website/login"</span>);</div></pre></td></tr></table></figure>
<p>In an ideal situation, filling out and submitting the form will look something like this.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Provide the selector of an input box and the content to type</span></div><div class="line"><span class="keyword">await</span> page.type(<span class="string">"input#username"</span>, CREDENTIALS.username);</div><div class="line"><span class="keyword">await</span> page.type(<span class="string">"input#password"</span>, CREDENTIALS.password);</div><div class="line"><span class="keyword">await</span> page.click(<span class="string">"button#login"</span>); <span class="comment">// Click the login button</span></div><div class="line"></div><div class="line"><span class="comment">// Wait until the screen changes and a node matching</span></div><div class="line"><span class="comment">// the selector #logged-in-successfully appears,</span></div><div class="line"><span class="comment">// at which point we know the login was successful</span></div><div class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">"#logged-in-successfully"</span>);</div></pre></td></tr></table></figure>
<p>We just successfully filled out a form and submitted an HTTP request containing our form data to a server. This is where Puppeteer shines. Let’s look at a more complicated example.</p>
<h2 id="A-More-Complicated-Example"><a href="#A-More-Complicated-Example" class="headerlink" title="A More Complicated Example"></a>A More Complicated Example</h2><p>Today’s web uses a mix of simple html driven forms as well as more complicated, javascript-driven forms, rich with functionality like autocomplete and dynamic dropdown menus. And of course there is the ubiquitous calendar date picker. These components each need to be treated differently.</p>
<p>Here is some a heavily modified version of some code I wrote for Fraight:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> fields = &#123;</div><div class="line">  equipment: <span class="string">'input[ng-model="equipment"]'</span>,</div><div class="line">  origin: <span class="string">'input[ng-model="origin"]'</span>,</div><div class="line">  destination: <span class="string">'input[ng-model="destination"]'</span>,</div><div class="line">  date: <span class="string">'input[ng-model="date"]'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> searchParams = getSearchParams();</div><div class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> <span class="keyword">this</span>.browser.newPage();</div><div class="line"><span class="keyword">await</span> page.goto(<span class="string">"https://website/search"</span>);</div><div class="line"></div><div class="line"><span class="comment">// We need to click a button to make the search form appear</span></div><div class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">".new-search"</span>);</div><div class="line"><span class="keyword">await</span> page.click(<span class="string">".new-search"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Fill out the form</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> field <span class="keyword">of</span> <span class="built_in">Object</span>.keys(fields)) &#123;</div><div class="line">  <span class="keyword">if</span> (searchParams[field]) &#123;</div><div class="line">    <span class="keyword">const</span> selector = fields[field];</div><div class="line"></div><div class="line">    <span class="comment">// We want to make sure each DOM node is accessible before</span></div><div class="line">    <span class="comment">// we try to do anything to it.</span></div><div class="line">    <span class="keyword">await</span> page.waitForSelector(selector);</div><div class="line"></div><div class="line">    <span class="comment">// Some inputs need to be focused first for page.type to work</span></div><div class="line">    <span class="comment">// Might as well focus on all of them</span></div><div class="line">    <span class="keyword">await</span> page.focus(selector);</div><div class="line"></div><div class="line">    <span class="comment">// Some inputs have defaults that need to be erased before typing</span></div><div class="line">    <span class="comment">// your own input</span></div><div class="line">    <span class="keyword">if</span> (field === <span class="string">"date"</span> || field === <span class="string">"equipment"</span>) &#123;</div><div class="line">      <span class="keyword">await</span> deleteInput(page, selector);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">await</span> page.type(selector, searchParams[field]);</div><div class="line"></div><div class="line">    <span class="comment">// This field won't register the typed data until Enter is pressed.</span></div><div class="line">    <span class="comment">// This is beacuse the equipment field is a dropdown where one of a</span></div><div class="line">    <span class="comment">// specific set of inputs must be clicked.</span></div><div class="line">    <span class="keyword">if</span> (field === <span class="string">"equipment"</span>) &#123;</div><div class="line">      <span class="keyword">await</span> page.keyboard.press(<span class="string">"Enter"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The first thing to notice is that the code is messy. It’s full of weird exceptions, each of which was discovered through trial and error. The worst thing about this code is that it doesn’t always work.</p>
<h2 id="Brace-Yourself-for-Flaky-Behavior"><a href="#Brace-Yourself-for-Flaky-Behavior" class="headerlink" title="Brace Yourself for Flaky Behavior"></a>Brace Yourself for Flaky Behavior</h2><p>Working with Puppeteer was truly an exercise in guesswork. My code often worked some percentage of the time. This non-deterministic, flaky behavior is what made this project so challenging. My code needs to be reliable and to have consistent behavior, but the reality of the matter is that given the exact same inputs, Puppeteer did not always produce the same outputs. I was required to do a lot of unnecessary engineering to increase reliability, which was a truly frustrating considering the alternative.</p>
<h2 id="Puppeteer-Was-Completely-Unnecessary"><a href="#Puppeteer-Was-Completely-Unnecessary" class="headerlink" title="Puppeteer Was Completely Unnecessary"></a>Puppeteer Was Completely Unnecessary</h2><p>Puppeteer has a API that allows you to execute arbitrary code against the DOM. After scraping form results with this API and getting the same flaky behavior I described above, I completely ditched the approach and started grabbing data from the HTTP response objects themselves. I wrote some handy code that allowed me to do this. Below is the code without error handling.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">waitForUrl(page, urlPrefix) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    page.on(<span class="string">"response"</span>, res =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!res.url.startsWith(urlPrefix)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      resolve(res.json());</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The page passed into this function is the same page object created above by the Puppeteer API. Among other things, it is an event emitter that allows me that listen for any HTTP responses received. I’ve essentially created a promise that resolves to the response of a particular ajax request. This allowed me interact with the server API directly and remove the DOM from the data retrieval process, greatly reducing the chance for flaky behavior. But that begs the question, why use Puppeteer at all? Why not simply send http requests to the server API manually and ditch the complicated form submission code above?<br>That’s really how I should have started all along.</p>
<h2 id="When-is-Puppeteer-the-Right-Solution"><a href="#When-is-Puppeteer-the-Right-Solution" class="headerlink" title="When is Puppeteer the Right Solution"></a>When is Puppeteer the Right Solution</h2><p>Puppeteer is the appropriate tool for scraping when a simple server API is inaccessible. If the information you want to extract from the webpage is generated using a combination of data from a server API and javascript code, then you have a great use case for Puppeteer. If all you need is data from the server, go the simple route and hit the API with an HTTP library like <a href="https://github.com/axios/axios" target="_blank" rel="external">axios</a> or <a href="https://github.com/request/request" target="_blank" rel="external">request</a></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/build-your-own-regex/">Build a Regex Engine in Less than 40 Lines of Code</a></h1>
  

      
        <time datetime="2017-11-28T17:36:04.000Z">2017-11-28</time>
      
    </header>
    <div class="entry">
      
        <p>I stumbled upon an <a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html" target="_blank" rel="external">article</a> the other day where Rob Pike implements a rudimentary regular expression engine in c. I converted his code to Javascript and added test specs so that someone can self-guide themselves through the creation of the regex engine. The specs and solution can be found in this <a href="https://github.com/nadrane/build-your-own-regex" target="_blank" rel="external">GitHub repository</a>. This blog post walks through my solution.</p>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Our regex engine will support the following syntax:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Meaning</th>
<th>Example</th>
<th>matches</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>Matches the specified character literal</td>
<td>q</td>
<td>q</td>
</tr>
<tr>
<td>*</td>
<td>Matches 0 or more of the previous character</td>
<td>a*</td>
<td>“”, a, aa, aaa</td>
</tr>
<tr>
<td>?</td>
<td>Matches 0 or 1 of the previous character</td>
<td>a?</td>
<td>“”, a</td>
</tr>
<tr>
<td>.</td>
<td>Matches any character literal</td>
<td>.</td>
<td>a, b, c, d, e …</td>
</tr>
<tr>
<td>^</td>
<td>Matches the start of a string</td>
<td>^c</td>
<td>c, ca, caa, cbb …</td>
</tr>
<tr>
<td>$</td>
<td>Matches the end of a string</td>
<td>a$</td>
<td>ba, baaa, qwerta …</td>
</tr>
</tbody>
</table>
<p>The goal is to provide a syntax robust enough to match a large portion of regex use cases with minimal code.</p>
<h2 id="Matching-One-Character"><a href="#Matching-One-Character" class="headerlink" title="Matching One Character"></a>Matching One Character</h2><p>The first step is to write a function that takes in a one character pattern and a one character text string and returns a boolean indicating if they match. A pattern of <code>.</code> is considered a wildcard and matches against any character literal.</p>
<p>Here are some examples</p>
<p><code>matchOne(&#39;a&#39;, &#39;a&#39;)</code> -&gt; <code>true</code><br><code>matchOne(&#39;.&#39;, &#39;z&#39;)</code> -&gt; <code>true</code><br><code>matchOne(&#39;&#39;, &#39;h&#39;)</code>  -&gt; <code>true</code><br><code>matchOne(&#39;a&#39;, &#39;b&#39;)</code> -&gt; <code>false</code><br><code>matchOne(&#39;p&#39;, &#39;&#39;)</code>  -&gt; <code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchOne</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!pattern) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Any text matches an empty pattern</span></div><div class="line">  <span class="keyword">if</span> (!text) <span class="keyword">return</span> <span class="literal">false</span>   <span class="comment">// If the pattern is defined but the text is empty, there cannot be a match</span></div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">"."</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Any inputted text matches the wildcard</span></div><div class="line">  <span class="keyword">return</span> pattern === text</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Matching-Same-Length-Strings"><a href="#Matching-Same-Length-Strings" class="headerlink" title="Matching Same Length Strings"></a>Matching Same Length Strings</h2><p>Now we want to add support for patterns and text strings of greater length. For now, let’s only consider a pattern/text pair of the same length. I happen to know that the solution lends itself very naturally to recursion, so we will use it here. We are going to want to repeatedly invoke <code>matchOne</code> on successive pairs of characters from the pattern/text combination.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// Our base case - if the pattern is empty, any inputted text is a match</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">1</span>), text.slice(<span class="number">1</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The above code advances character by character across the the pattern/text pair. It first compares <code>pattern[0]</code> to <code>text[0]</code> and then <code>pattern[1]</code> to <code>text[1]</code> and continues comparing <code>pattern[i]</code> to <code>text[i]</code> until <code>i === pattern.length - 1</code>. If they ever don’t match, then we know that the pattern cannot match the text.</p>
<p>Let’s take an example. Suppose we invoke <code>match(&#39;a.c&#39;, &#39;abc&#39;)</code>, which returns <code>matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; match(&#39;.c&#39;, &#39;bc&#39;)</code>.</p>
<p>If we continue evaluating these functions, we get <code>matchOne(&#39;a&#39;, &#39;a&#39;) &amp;&amp; matchOne(&#39;.&#39;, &#39;b&#39;) &amp;&amp; matchOne(&#39;c&#39;, &#39;c&#39;) &amp;&amp; match(&quot;&quot;, &quot;&quot;)</code>, which is just equal to <code>true &amp;&amp; true &amp;&amp; true &amp;&amp; true</code>, So we have a match!</p>
<h2 id="The-Character"><a href="#The-Character" class="headerlink" title="The $ Character"></a>The $ Character</h2><p>Let’s add support for the special pattern character <code>$</code> that allows us to match the end of a string. The solution simply requires adding an additional base case to the match function.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">"$"</span> &amp;&amp; text === <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">1</span>), text.slice(<span class="number">1</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-Character-1"><a href="#The-Character-1" class="headerlink" title="The ^ Character"></a>The ^ Character</h2><p>Let’s add support for the special pattern character <code>^</code> that allows us to match the beginning of a string. I’m going to introduce a new function called <code>search</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern[<span class="number">0</span>] === <span class="string">"^"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> match(pattern.slice(<span class="number">1</span>), text)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This function will be the new entry point to our code. Up till this point, we were only matching patterns that began at the beginning of the text. We are simply making that more clear now by forcing the user to preface the pattern with a <code>^</code>. But how do we support patterns that appear anywhere within the text?</p>
<h2 id="Matches-Starting-Anywhere"><a href="#Matches-Starting-Anywhere" class="headerlink" title="Matches Starting Anywhere"></a>Matches Starting Anywhere</h2><p>Currently, the following return <code>true</code></p>
<p><code>search(&quot;^abc&quot;, &quot;abc&quot;)</code><br><code>search(&quot;^abcd&quot;, &quot;abcd&quot;)</code></p>
<p>But <code>search(&quot;bc&quot;, &quot;abcd&quot;)</code> will just return <code>undefined</code>. We want it to return <code>true</code></p>
<p>If the user does not specify that the pattern matches the beginning of the text, then we want to search for that pattern at every possible starting point within the text. We will default to this behavior if the pattern does not begin with <code>^</code><sup><a href="#footnote1">1</a></sup>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern[<span class="number">0</span>] === <span class="string">"^"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> match(pattern.slice(<span class="number">1</span>), text)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// This code will run match(pattern, text.slice(index)) on every index of the text.</span></div><div class="line">    <span class="comment">// This means that we test the pattern against every starting point of the text.</span></div><div class="line">    <span class="keyword">return</span> text.split(<span class="string">""</span>).some(<span class="function">(<span class="params">_, index</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> match(pattern, text.slice(index))</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-Character-2"><a href="#The-Character-2" class="headerlink" title="The ? Character"></a>The ? Character</h2><p>We want to be able to match 0 to 1 of the character before <code>?</code>.</p>
<p>Here are some examples</p>
<p><code>search(&quot;ab?c&quot;, &quot;ac&quot;)</code>    -&gt; <code>true</code><br><code>search(&quot;ab?c&quot;, &quot;abc&quot;)</code>   -&gt; <code>true</code><br><code>search(&quot;a?b?c?&quot;, &quot;abc&quot;)</code> -&gt; <code>true</code><br><code>search(&quot;a?b?c?&quot;, &quot;&quot;)</code>    -&gt; <code>true</code></p>
<p>The first step is to modify <code>match</code> to detect when a <code>?</code> character is present and then delegate to the <code>matchQuestion</code> function, which we will define shortly.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">""</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern === <span class="string">"$"</span> &amp;&amp; text === <span class="string">""</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  <span class="comment">// Notice that we are looking at pattern[1] instead of pattern[0].</span></div><div class="line">  <span class="comment">// pattern[0] is the character to match 0 or 1 of.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[<span class="number">1</span>] === <span class="string">"?"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> matchQuestion(pattern, text)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">1</span>), text.slice(<span class="number">1</span>))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>matchQuestion</code> needs to handle two cases:</p>
<ol>
<li>Where the character before the <code>?</code> is not matched but the text matches the remainder of the pattern (everything after the <code>?</code>).</li>
<li>Where the character before the <code>?</code> is matched and the rest of the text (minus the 1 matched character) matches the remainder of the pattern.</li>
</ol>
<p>If either of these cases is truthy, then <code>matchQuestion</code> can return <code>true</code>.</p>
<p>Let’s consider the first case. How do we check if the text matches everything in the pattern except the <code>_?</code> syntax? In order words, how do we check if the character before the <code>?</code> appears 0 times? We strip 2 characters off the pattern (the first character is the one before the <code>?</code> and the second is the <code>?</code> itself) and invoke the match function.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchQuestion</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> match(pattern.slice(<span class="number">2</span>), text);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The second case is a little more challenging, but just like before, it reuses functions we’ve already written</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchQuestion</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">2</span>), text.slice(<span class="number">1</span>))) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> match(pattern.slice(<span class="number">2</span>), text);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If the <code>text[0]</code> matches <code>pattern[0]</code>, and the rest of the text (minus the part that is matched by <code>matchOne</code>) matches the remainder of the pattern, then we are golden. Note that we could rewrite the code like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchQuestion</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">2</span>), text.slice(<span class="number">1</span>))) || match(pattern.slice(<span class="number">2</span>), text);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The one thing I like about this latter approach is that the boolean OR makes it explicitly clear that there are two cases, either of which may be true.</p>
<h2 id="The-Character-3"><a href="#The-Character-3" class="headerlink" title="The * Character"></a>The * Character</h2><p>We want to be able to match the character before the <code>*</code> 0 or more times.</p>
<p>All of these should return <code>true</code>.</p>
<p><code>search(&quot;a*&quot;, &quot;&quot;)</code><br><code>search(&quot;a*&quot;, &quot;aaaaaaa&quot;)</code><br><code>search(&quot;a*b&quot;, &quot;aaaaaaab&quot;)</code></p>
<p>Similar to what we did when supporting <code>?</code>, we wan to delegate to a <code>matchStar</code> function within our <code>match</code> function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">""</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern === <span class="string">"$"</span> &amp;&amp; text === <span class="string">""</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[<span class="number">1</span>] === <span class="string">"?"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> matchQuestion(pattern, text)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[<span class="number">1</span>] === <span class="string">"*"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> matchStar(pattern, text)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern.slice(<span class="number">1</span>), text.slice(<span class="number">1</span>))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>matchStar</code>, like <code>matchQuestion</code>, also needs to handle two cases:</p>
<ol>
<li>Where the character before the <code>*</code> is not matched but the text matches the remainder of the pattern (everything after the <code>*</code>).</li>
<li>Where the character before the <code>*</code> is matched one or more times and the rest of the text matches the remainder of the pattern.</li>
</ol>
<p>Since there are two cases that both result in a match (0 matches OR more matches), we know that <code>matchStar</code> can be implemented with a boolean OR. Furthermore, case 1 for <code>matchStar</code> is exactly the same as it was for <code>matchQuestion</code> and can be implemented identically using <code>match(pattern.slice(2), text)</code>. That means we only need to formulate an expression that satisfies case 2.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchStar</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (matchOne(pattern[<span class="number">0</span>], text[<span class="number">0</span>]) &amp;&amp; match(pattern, text.slice(<span class="number">1</span>))) || match(pattern.slice(<span class="number">2</span>), text);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Refactoring"><a href="#Refactoring" class="headerlink" title="Refactoring"></a>Refactoring</h2><p>We can now go back and cleverly simplify <code>search</code> using a trick I learned in Peter Norvig’s <a href="https://www.udacity.com/course/design-of-computer-programs--cs212" target="_blank" rel="external">class</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">pattern, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (pattern[<span class="number">0</span>] === <span class="string">"^"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> match(pattern.slice(<span class="number">1</span>), text)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> match(<span class="string">".*"</span> + pattern, text)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We use the <code>*</code> character itself to allow for the pattern to appear anywhere in the string. The prepended <code>.*</code> says that any number of any character can appear before the pattern we wish to match.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>It’s remarkable how simple and elegant the code for such a sophisticated and generalized program can be. The full source is available in this <a href="https://github.com/nadrane/build-your-own-regex" target="_blank" rel="external">GitHub repository</a></p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p><a name="footnote1">1</a>: There is a small bug in this code that I’m choosing to ignore. We don’t account for the case that text is an empty string. Currently when <code>text === &#39;&#39;</code>, <code>text.split(&quot;&quot;)</code> will return <code>[]</code> and will not appropriately call <code>match</code>.</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/write-your-own-redux-connect/">Write Your Own React-Redux Connect</a></h1>
  

      
        <time datetime="2017-09-29T18:14:18.000Z">2017-09-29</time>
      
    </header>
    <div class="entry">
      
        <p><em>My inspiration for this blog post came from <a href="https://www.youtube.com/watch?v=VJ38wSFbM3A" target="_blank" rel="external">this video</a> where Dan Abramov walks through the source code to react-redux</em></p>
<p>As frontend web developers, it’s not uncommon that we follow well-specified patterns - often blindly. The frontend landscape is changing rapidly, and sometimes there isn’t time to investigate why we use a specific pattern; we just know we should.</p>
<p>One widely used pattern in <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">react-redux</a> applications looks like this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</div></pre></td></tr></table></figure>
<p>I’ll assume you know how to implement this pattern, but why do we use it and how does it work under the hood?</p>
<h1 id="Why-Do-we-Need-React-Redux"><a href="#Why-Do-we-Need-React-Redux" class="headerlink" title="Why Do we Need React-Redux?"></a>Why Do we Need React-Redux?</h1><p>React and Redux are two completely independent tools that have nothing to do with each other. React is a tool for creating user interfaces in the browser. Redux is a tool for managing state. Either tool can be used without the other. We often use them together because they both solve separate but very important and closely related problems. The purpose of react-redux is to get these two tools to talk.</p>
<p>But first, what would we do without react-redux? How would React and Redux talk?</p>
<h1 id="How-to-Integrate-React-and-Redux-Without-react-redux"><a href="#How-to-Integrate-React-and-Redux-Without-react-redux" class="headerlink" title="How to Integrate React and Redux Without react-redux"></a>How to Integrate React and Redux Without react-redux</h1><p>More precisely, how do we ensure that a React component re-renders when the Redux store changes? The answer lies in Redux’s <a href="http://redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external">subscribe</a> API.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></div><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="comment">// One solution is to make each component</span></div><div class="line">    <span class="comment">// store the entirety of the redux state.</span></div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="comment">// Callbacks passed to store.subscribe will be</span></div><div class="line">    <span class="comment">// invoked every time the store's state changes.</span></div><div class="line">    <span class="comment">// Our callback can get the state of the</span></div><div class="line">    <span class="comment">// store and add it to the component's local state.</span></div><div class="line">    <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// We need to make sure that we don't accidentally</span></div><div class="line">  <span class="comment">// subscribe to the store multiple times in the case</span></div><div class="line">  <span class="comment">// where a component mounts, unmounts, and then mounts a second time.</span></div><div class="line">  <span class="comment">// Fortunately, Redux makes this easy by returning</span></div><div class="line">  <span class="comment">// an unsubscribe function when store.subscribe is invoked.</span></div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    <span class="keyword">this</span>.unsubscribe();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If we insert the above boilerplate into every one of our React component’s, then every component could have access to the store and would be informed through a subscription the moment the store’s state changes. This configuration has three  flaws.</p>
<ol>
<li>The boilerplate of subscribing and unsubscribing to the store is highly error prone and unnecessarily verbose.</li>
<li>All of our React component’s are dependent upon knowledge of the Redux store. This is a complete failure of <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="external">separation of concerns</a>.</li>
<li>Every component is dependent upon the entirety of the store’s state tree. This means that whenever an action is dispatched, <code>setState</code> is called on every mounted component, causing each one to re-render, regardless of whether its render function depends on the store state that changed. Woah! Let that sink in for a moment.</li>
</ol>
<p>Let’s write a rudimentary implementation of connect that resolves the first problem.</p>
<h1 id="Understanding-The-Syntax-of-Connect"><a href="#Understanding-The-Syntax-of-Connect" class="headerlink" title="Understanding The Syntax of Connect"></a>Understanding The Syntax of Connect</h1><p>Typically, we invoke <code>connect</code> like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);</div></pre></td></tr></table></figure>
<p><code>connect</code> takes in two functions as arguments and returns a function. Yes, you heard me, <code>connect</code> returns a function, not a component. Suppose I invoke <code>connect</code> and neglect to pass in a component.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> connectFunc = connect(mapStateToProps, mapDispatchToProps);</div><div class="line"><span class="keyword">const</span> connctedComponent = connectFunc(WrappedComponent);</div></pre></td></tr></table></figure>
<p> <code>connect</code> will return to me a function. It’s that function that takes in my component (<code>connect</code> is implemented this way as opposed to simply taking in 3 arguments to support decorator syntax. The Dan Abramov video I linked above explains this.)</p>
<p>Thus, the very first few lines of <code>connect</code> must look like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line"></div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Higher-Order-Components"><a href="#Higher-Order-Components" class="headerlink" title="Higher Order Components"></a>Higher Order Components</h1><p>And what does the function we returned above do? This function is implemented as a <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">higher order component</a> (HOC). A HOC is a function that takes in a component as a parameter and returns a new component. The new component is generally a modified or augmented version of the original component.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="comment">// We are returning a brand new component.</span></div><div class="line">    <span class="comment">// Note that this new component does</span></div><div class="line">    <span class="comment">// not inherit from WrappedComponent.</span></div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="comment">// All we are doing is returning a new component</span></div><div class="line">      <span class="comment">// that renders our original component.</span></div><div class="line">      render() &#123;</div><div class="line">        <span class="comment">// Notice that we need to pass WrappedComponent</span></div><div class="line">        <span class="comment">// WrapperComponent's props.</span></div><div class="line">        <span class="comment">// If we didn't do this, then WrappedComponent</span></div><div class="line">        <span class="comment">// would never have access to any props.</span></div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If we were to run the above <code>connect</code> function on a component, the connected component would behave identically to original component. Furthermore, we could nest <code>connect</code> as many times as we want</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(<span class="literal">null</span>, <span class="literal">null</span>)(connect(<span class="literal">null</span>, <span class="literal">null</span>)(App))</div></pre></td></tr></table></figure>
<p>and still never distort the behavior of the original component. Our current implementation is effectively <a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation" target="_blank" rel="external">idempotent</a>.</p>
<h1 id="Eliminating-Boilerplate"><a href="#Eliminating-Boilerplate" class="headerlink" title="Eliminating Boilerplate"></a>Eliminating Boilerplate</h1><p>Our next step is to eliminate some of the boilerplate code. We don’t want to have to subscribe to the store every time we create a new component, so let’s have our new <code>connect</code> function do it instead.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render() &#123;</div><div class="line">        <span class="comment">// Since the whole point of this HOC is to get WrappedComponent</span></div><div class="line">        <span class="comment">// access to the store, we need to pass that state down as props.</span></div><div class="line">        <span class="keyword">const</span> storeState = <span class="keyword">this</span>.state.storeState;</div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...storeState&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We just made huge progress! Now, whenever we invoke</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(<span class="literal">null</span>, <span class="literal">null</span>)(MyComponent)</div></pre></td></tr></table></figure>
<p>we get a component that is subscribed to state changes on the store, and this state will be passed down to our component as props.</p>
<h1 id="Implementing-Support-for-mapStateToProps"><a href="#Implementing-Support-for-mapStateToProps" class="headerlink" title="Implementing Support for mapStateToProps"></a>Implementing Support for mapStateToProps</h1><p>Our connected components still all depend on the entirety of the store’s state tree. Look up above, the entire state is passed down as props to every connected component. To reiterate, this means that if any piece of the store’s state is updated, our component will re-render.</p>
<p>This is where <code>mapStateToProps</code> comes to the rescue. <code>mapStateToProps</code> takes as its argument the store’s state, and it allows us to return the particular pieces of the store’s state that a component depends on. It then passes that state as props to our component instead.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render() &#123;</div><div class="line">        <span class="comment">// Now, instead of passing down all of the store state,</span></div><div class="line">        <span class="comment">// we only pass down the subset of state return from</span></div><div class="line">        <span class="comment">// mapStateToProps</span></div><div class="line">        <span class="keyword">const</span> storeProps = mapStateToProps(<span class="keyword">this</span>.state.storeState);</div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...storeProps&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>All we did was insert a call to <code>mapStateToProps</code>, allowing us to make each connected component dependent upon only the state it cares about, as defined by the return value of <code>mapStateToProps</code>. <code>mapStateToProps</code> is a wonderful form of explicit documentation, clearly stating the slices of the state tree each component depends on. Unfortunately, our change does not fix the efficiency problems noted above. More on that below.</p>
<h1 id="mapStateToProps-and-ownProps"><a href="#mapStateToProps-and-ownProps" class="headerlink" title="mapStateToProps and ownProps"></a>mapStateToProps and ownProps</h1><p>An astute reader might note that <code>mapStateToProps</code> actually takes two arguments: the first is a copy of the store’s state, and the second are the props that are originally passed down to <code>WrapperComponent</code>. <code>react-redux</code> does not pass these down to the wrapped component by default as we do in the example immediately above. Let’s modify our implementation to mirror <code>react-redux</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render() &#123;</div><div class="line">        <span class="keyword">const</span> newProps = mapStateToProps(<span class="keyword">this</span>.state.storeState, <span class="keyword">this</span>.props);</div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...newProps&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now the implementer of <code>mapStateToProps</code> can choose which of <code>WrapperComponent</code>‘s props it would like to keep and which it would like to disregard.</p>
<h1 id="What’s-the-Point-of-mapDispatchToProps"><a href="#What’s-the-Point-of-mapDispatchToProps" class="headerlink" title="What’s the Point of mapDispatchToProps?"></a>What’s the Point of mapDispatchToProps?</h1><p><code>mapDispatchToProps</code> is designed to eliminate React’s dependency upon Redux. If we were to use the above implementation of <code>connect</code>, every component that dispatch’s an action must import <code>store.dispatch</code>, and the implementation would look like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"./store"</span>;</div><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</div><div class="line"><span class="keyword">import</span> &#123; updateThing &#125; <span class="keyword">from</span> <span class="string">"./store/actions"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  handleChange(e) &#123;</div><div class="line">    store.dispatch(updateThing(e.target));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The above component ‘knows’ that it is part of a Redux application because it is explicitly referencing the store to dispatch actions. But we should always try to minimize the interaction of different pieces of architecture, esspecially when they have no need to interact. Ultimately, React components should not been intertwined with Redux code!</p>
<h2 id="Implementing-Support-for-mapDispatchToProps"><a href="#Implementing-Support-for-mapDispatchToProps" class="headerlink" title="Implementing Support for mapDispatchToProps"></a>Implementing Support for mapDispatchToProps</h2><p><code>connect</code> resolves this problem for us by injecting the <code>store.dispatch</code> dependency into <code>mapDispatchToProps</code>, allowing us to explicitly define functions that dispatch actions without requiring that our <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="external">presentation components</a> have a dependency on the store. Just as the return value of <code>mapStateToProps</code> is passed down to <code>WrappedComponent</code>, the return value of <code>mapDispatchToProps</code> will be passed down as well.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render() &#123;</div><div class="line">        <span class="comment">// Now we merge the results from mapStateToProps</span></div><div class="line">        <span class="comment">// and mapDispatchToProps and pass everything down</span></div><div class="line">        <span class="keyword">const</span> newProps = <span class="built_in">Object</span>.assign(</div><div class="line">          &#123;&#125;,</div><div class="line">          mapStateToProps(<span class="keyword">this</span>.state.storeState, <span class="keyword">this</span>.props),</div><div class="line">          <span class="comment">// If you aren't intimately familiar with the this keyword,</span></div><div class="line">          <span class="comment">// it's okay if you don't understand why we use bind here</span></div><div class="line">          mapDispatchToProps(store.dispatch.bind(<span class="keyword">this</span>))</div><div class="line">        );</div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...newProps&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="More-Efficiency-Issues-Hello-shouldComponentUpdate"><a href="#More-Efficiency-Issues-Hello-shouldComponentUpdate" class="headerlink" title="More Efficiency Issues - Hello shouldComponentUpdate"></a>More Efficiency Issues - Hello shouldComponentUpdate</h1><p>We never actually fixed any of the performance issues noted above. The crux of the problem is that every time the store updates, <code>WrapperComponent</code> re-renders (because of its Redux store subscription that calls <code>setState</code>) and that means <code>WrappedComponent</code> re-renders. This <a href="/leveraging-immutability-in-react">re-rendering</a> happens despite the fact that <code>WrappedComponent</code>‘s props might be unchanged between two invocations of <code>setState</code>. In fact, this scenario is highly probable and will occur whenever a piece of state in the store changes that your component does not depend on (aka, a piece of store state not returned from from <code>mapStateToProps</code>).</p>
<p>React has a handy lifecycle method called <a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external"><code>shouldComponentUpdate</code></a> that allows us to return a boolean that indicates whether a component should re-render. In essence, if we implement this method on <code>WrapperComponent</code> and it returns <code>false</code>, then React will not re-render <code>WrapperComponent</code>. And it follows that <code>WrappedComponent</code> won’t re-render either.</p>
<p>So, in the above scenario, when <code>WrapperComponent</code> calls <code>setState</code>, React first calls the <code>shouldComponentUpdate</code> method to see if a re-render should actually happen. Let’s implement it below.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Just a simple shallow equality function</span></div><div class="line"><span class="keyword">import</span> shallowEqual <span class="keyword">from</span> <span class="string">"shallow-equal/objects"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">storeState</span>: store.getState() &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      shouldComponentUpdate() &#123;</div><div class="line">        <span class="comment">// If the props to WrapperComponent do not change</span></div><div class="line">        <span class="comment">// between setState calls, then we don't need to re-render.</span></div><div class="line">        <span class="comment">// On the previous re-render, we cached the results of</span></div><div class="line">        <span class="comment">// mapStateToProps. That's what this.oldProps is.</span></div><div class="line">        <span class="keyword">const</span> newProps = mapStateToProps(<span class="keyword">this</span>.state.storeState, <span class="keyword">this</span>.props);</div><div class="line">        <span class="keyword">return</span> !shallowEqual(newProps, <span class="keyword">this</span>.oldProps);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">storeState</span>: store.getState() &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render() &#123;</div><div class="line">        <span class="comment">// We need to hang onto the previous result of</span></div><div class="line">        <span class="comment">// mapStateToProps to use the next time</span></div><div class="line">        <span class="comment">// shouldComponentUpdate runs</span></div><div class="line">        <span class="keyword">this</span>.oldProps = mapStateToProps(<span class="keyword">this</span>.state.storeState, <span class="keyword">this</span>.props)</div><div class="line">        <span class="keyword">const</span> newProps = <span class="built_in">Object</span>.assign(</div><div class="line">          &#123;&#125;,</div><div class="line">          <span class="keyword">this</span>.oldProps,</div><div class="line">          mapDispatchToProps(store.dispatch.bind(<span class="keyword">this</span>))</div><div class="line">        );</div><div class="line">        <span class="keyword">return</span> &lt;WrappedComponent &#123;...newProps&#125; /&gt;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>I’ve created a demo <a href="https://codesandbox.io/s/o43p70k66" target="_blank" rel="external">here</a>. Open the console and prove to yourself that <code>shouldComponentUpdate</code> is doing its job.</p>
<p><em>I should note that this is not exactly what react-redux does because of edge cases, but the concept is still the same.</em></p>
<p>Now our wrapper and wrapped components will only re-render when the props returned from <code>mapStateToProps</code> change! This is a huge performance gain. This implementation of <code>connect</code> explains why adherence to <a href="http://redux.js.org/docs/faq/ReactRedux.html#react-not-rerendering" target="_blank" rel="external">immutability is so important</a> in redux’s reducers. If you fail to respect immutability, the shallow comparison in the <code>shouldComponentUpdate</code> in <code>WrapperComponent</code> will likely return <code>false</code>, causing your connected component to not re-render when it should.</p>
<h1 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h1><p>React-redux’s <code>connect</code> method is remarkably simple and only performs a handful of operations.</p>
<ol>
<li>It manages our component’s subscription to the store so that our component can update when the store updates.</li>
<li>It allows us to explicitly define the slice of state our component is dependent upon using <code>mapStateToProps</code>.</li>
<li>It gives our component access to <code>store.dispatch</code> without requiring a direct dependency on the store.</li>
<li>It defines <code>shouldComponentUpdate</code>, ensuring that our components only re-render when the store state they depend on changes.</li>
</ol>
<p>I hope you found this article helpful. Please feel free to email me and reach out if you have questions. I put a <a href="https://gist.github.com/nadrane/5221c64c421efe421bda9fdaab167dc2" target="_blank" rel="external">gist</a> online containing the same code as the demo.</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/using-reduce/">Using Reduce</a></h1>
  

      
        <time datetime="2017-09-28T15:36:30.000Z">2017-09-28</time>
      
    </header>
    <div class="entry">
      
        <p>My first introduction to functional programming was a couple years ago when I read through the famous <a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">SICP</a>. As someone who had up to this point worked with mostly in object oriented and imperative languages, I had rarely seen <code>map</code>, <code>fitler</code>, and <code>reduce</code> before that time. The purpose of the former two felt obvious; the latter one not so much. This blog post is geared for someone who knows how <code>reduce</code> works but feels like they struggle to use it practically.</p>
<h2 id="Reduce-Basics"><a href="#Reduce-Basics" class="headerlink" title="Reduce Basics"></a>Reduce Basics</h2><p><em>Feel free to skip this section if you understand the basics of reduce</em></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=a" target="_blank" rel="external">Reduce</a> is known as a higher order function (HOF). A HOF is defined as a function that either takes in or returns another function.</p>
<p>Reduce takes two parameters: the first is a function, and the second is known as the initial accumulator. We will invoke this function over every element of an array. The ultimate goal is to transform the array into something new.</p>
<p>Suppose we want to take an array of characters and concatenate them into a single string. In this example, the first argument we pass reduce is a HOF that will operate over every character. The HOF takes two arguments: the first is the accumulator and is the value that we ultimately want to assemble, and the second is a particular element of the array.</p>
<p>Let’s simulate what happens when we run a solution to the problem of concatenating strings.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arrToConcat = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line">arrToConcat.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">resultantString, nextCharacter</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> resultantString + nextCharacter;</div><div class="line">&#125;, <span class="string">""</span>)  <span class="comment">// initial accumulator. This is the second argument to reduce!</span></div></pre></td></tr></table></figure>
<p>You can use the below table to help guide yourself along</p>
<table>
<thead>
<tr>
<th style="text-align:center">invocation #</th>
<th style="text-align:center">resultantString</th>
<th style="text-align:center">nextCharacter</th>
<th style="text-align:center">return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">“”</td>
<td style="text-align:center">‘a’</td>
<td style="text-align:center">‘a’</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">“a”</td>
<td style="text-align:center">‘b’</td>
<td style="text-align:center">‘ab’</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">“ab”</td>
<td style="text-align:center">‘c’</td>
<td style="text-align:center">‘abc’</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">“abc”</td>
<td style="text-align:center">‘d’</td>
<td style="text-align:center">‘abcd’</td>
</tr>
</tbody>
</table>
<p>We will ultimately call our HOF 4 times, passing in each of the 4 elements in the initial array.</p>
<p>The first time we invoke the HOF, the first argument is always the initial accumulator. Notice the <code>&quot;&quot;</code> passed into reduce above. The second argument is <code>&#39;a&#39;</code> because that’s the first element in our array. We return ‘a’, and this return value is the <code>resultantString</code> that is passed as an argument to the second invocation of our HOF, along with the next element of the array, <code>&#39;b&#39;</code>. The process continues. <code>&#39;ab&#39;</code> is returned from the HOF’s second invocation, and <code>&#39;ab&#39;</code> and <code>&#39;c&#39;</code> are passed into the third invocation of the HOF. Ultimately, <code>reduce</code> returns <code>&#39;abcd&#39;</code>.</p>
<p>We built up the result step by step through a series of concatenation steps. Every call to the HOF will return a string with one additional character added to the previous accumulator.</p>
<h2 id="Know-Your-Return-Type"><a href="#Know-Your-Return-Type" class="headerlink" title="Know Your Return Type"></a>Know Your Return Type</h2><p>I think one of the reasons <code>map</code> and <code>filter</code> are easier than <code>reduce</code> is because they always return an array. That’s not the case for <code>reduce</code>. <code>reduce</code> is ultimately designed to transform one type into another.</p>
<p>When you begin writing a <code>reduce</code> statement, your first question to yourself should be “What type am I returning?”. Here’s a hint, it’s probably one of the following: <code>String</code>, <code>Number</code>, <code>Object</code>, <code>Array</code>. Once you know what type you will return you can begin writing your reduce statement. I say this because the initial accumulator (reduce’s second argument) can easily be determined by what type you expect <code>reduce</code> to return. Here is a table to guide your decision.</p>
<table>
<thead>
<tr>
<th style="text-align:center">return type</th>
<th style="text-align:center">initial accumulator</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">“”</td>
</tr>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">object</td>
<td style="text-align:center">{}</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">[]</td>
</tr>
</tbody>
</table>
<p><strong>Notice that the initial accumulator and the return type are always the same!</strong></p>
<p><em>You probably won’t want return an array from a reduce function very often because chances are you could have more simply used a combination of <code>map</code>, <code>filter</code>, and/or some other function instead.</em></p>
<h2 id="Summing-Odd-Numbers"><a href="#Summing-Odd-Numbers" class="headerlink" title="Summing Odd Numbers"></a>Summing Odd Numbers</h2><p>So let’s say we want to reduce over a set of numbers and return the sum of all the odd numbers. Since we are returning a <code>number</code>, we can use the above table to determine that the starting accumulator should be 0. That gives us a pretty decent starting point!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arrToSum = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">arrToSum.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">currentSum, nextNumber</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;, <span class="number">0</span>)  <span class="comment">// This is the second argument to reduce!</span></div></pre></td></tr></table></figure>
<p>Now we just need to complete the guts of the function such that it increments the sum when the <code>nextNumber</code> is odd. If <code>nextNumber</code> is even, it should return <code>currentSum</code> unchanged.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arrToSum = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">arrToSum.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">currentSum, nextNumber</span>) </span>&#123;</div><div class="line">  <span class="comment">// nextNumber is odd</span></div><div class="line">  <span class="keyword">if</span> (nextNumber % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> currentSum + nextNumber</div><div class="line">  <span class="comment">// nextNumber is even</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> currentSum</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>One interesting thing to note about the above code is that EVERY code path (every if-else block) returns something. This is a very common theme throughout the functional programming paradigm and holds true when writing reduce’s higher order function. In general it’s a decent litmus test to establish if you’ve made a bug somewhere. <strong>More specifically, if every code path does not return something, and if that something is not the same type as your accumulator, you probably have a bug.</strong></p>
<h2 id="Frequency-Counter"><a href="#Frequency-Counter" class="headerlink" title="Frequency Counter"></a>Frequency Counter</h2><p>Let’s do something a little different. Suppose I have an array of words, and I want to count how many times each word appears in the array. We can represent this information using an object that maps words in the array to a number indicating their frequency of occurrence.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We will input something like this</span></div><div class="line">[<span class="string">'luke'</span>, <span class="string">'anakin'</span>, <span class="string">'chewy'</span>, <span class="string">'luke'</span>, <span class="string">'chewy'</span>, <span class="string">'princess'</span>, <span class="string">'leia'</span>, <span class="string">'chewy'</span>] -&gt;</div><div class="line"></div><div class="line"><span class="comment">// And output something like this</span></div><div class="line">&#123;</div><div class="line">  luke: <span class="number">2</span>,</div><div class="line">  anakin: <span class="number">1</span>,</div><div class="line">  princess: <span class="number">1</span>,</div><div class="line">  chewy: <span class="number">3</span>,</div><div class="line">  leia: <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Consulting the table above, we know that the starting accumulator needs to be an empty object. This means that each iteration over the array returns an object as well.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> frequencyArray = [<span class="string">'luke'</span>, <span class="string">'anakin'</span>, <span class="string">'chewy'</span>, <span class="string">'luke'</span>, <span class="string">'chewy'</span>, <span class="string">'princess'</span>, <span class="string">'leia'</span>, <span class="string">'chewy'</span>];</div><div class="line">frequencyArray.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">resultantObject, nextWord</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;, &#123;&#125;)</div></pre></td></tr></table></figure>
<p>Every step of the higher order function needs to examine the next word and determine if it has been seen before. If it has not, then we need to add an entry to the accumulator and return it. If it has, then we need to increment the existing entry inside the accumulator object and return it.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">frequencyArray.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">resultantObject, nextWord</span>) </span>&#123;</div><div class="line">  <span class="comment">// If the word is not in the object</span></div><div class="line">  <span class="keyword">if</span> (!resultantObject.hasOwnProperty(nextWord)) &#123;</div><div class="line">    resultantObject[nextWord] = <span class="number">1</span> <span class="comment">//Set it to 1 since we have seen the word before</span></div><div class="line">    <span class="keyword">return</span> resultantObject</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Otherwise increment the counter for that word inside the resulting object</span></div><div class="line">    resultantObject[nextWord]++</div><div class="line">    <span class="keyword">return</span> resultantObject</div><div class="line">  &#125;</div><div class="line">&#125;, &#123;&#125;)</div></pre></td></tr></table></figure>
<p>Just like the first example, every code path returns the type of the accumulator.</p>
<h2 id="Merging-Objects"><a href="#Merging-Objects" class="headerlink" title="Merging Objects"></a>Merging Objects</h2><p>Let’s end with something a little more complicated.</p>
<p>Suppose we want to implement a merge function to combines several objects into a single object. We’re going to implement something really similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign</a>. Here are some examples.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">merge([ &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">c</span>:<span class="number">10</span> &#125; ]) --&gt; &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">10</span> &#125;</div><div class="line"></div><div class="line">merge([ &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">c</span>:<span class="number">4</span> &#125;, &#123;<span class="attr">f</span>: <span class="number">7</span>&#125; ]) --&gt; &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">f</span>: <span class="number">7</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// Duplicate keys take the value of the latter object</span></div><div class="line">merge([ &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">c</span>:<span class="number">4</span> &#125;, &#123;<span class="attr">a</span>: <span class="number">7</span>&#125; ]) --&gt; &#123; <span class="attr">a</span>: <span class="number">7</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>We know that the return value from this operation is an object, so that will be our starting accumulator. Every iteration of the array will produce a new object that contains the merging of the previous accumulator and the next object.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This merge function will take in two objects and output a new object</span></div><div class="line"><span class="comment">// containing both the keys and values from the two input objects.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwo</span>(<span class="params">obj1, obj2</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> newObj = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</div><div class="line">    newObj[key] = obj1[key]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj2) &#123;</div><div class="line">    newObj[key] = obj2[key]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newObj</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">resultantObj, nextObj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> mergeTwo(resultantObj, nextObj)</div><div class="line">  &#125;, &#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize</p>
<ol>
<li>Always start by asking what the type of your output is. The type of your accumulator will follow by using the mapping table.</li>
<li>The logic inside your higher order function should assemble your resulting accumulator piecemeal. Since the return value of the previous iteration is the input to the next iteration, every code path must return a value</li>
<li>Furthermore, unless you want a horrible experience, every code path MUST return a value whose type is the same as that of your initial accumulator.</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>At the end of the day, just about everything you can do with reduce can be done with some combination of <code>map</code> and <code>fitler</code> and perhaps another <a href="https://lodash.com/docs/4.17.4]" target="_blank" rel="external">functional method</a>. And the alternative solution is almost always simpler and more readable. So, in practice, you probably don’t want to use <code>reduce</code> that often. With that said, <code>reduce</code> is a building block on which every other functional method can be built, and we will explore this unique trait in my next blog post.</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/leveraging-immutability-in-react/">Leveraging Immutability in React</a></h1>
  

      
        <time datetime="2017-09-27T14:30:27.000Z">2017-09-27</time>
      
    </header>
    <div class="entry">
      
        <p>React has taken the web development community by a storm, and with it functional programming concepts have embedded themselves in the mainstream. One common statement you will often read is that all state in React should be immutable, and this practice is justified as necessary for performance reasons. This statement is entirely true, but it only tells half the truth. Immutability alone will not yield any performance gains in React (it’ll actually make things slower).</p>
<h2 id="The-Quick-Answer"><a href="#The-Quick-Answer" class="headerlink" title="The Quick Answer"></a>The Quick Answer</h2><p>You can reap the gains from immutable state in React if you inherit from <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="external">React.PureComponent</a> instead of <code>React.Component</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<h2 id="A-Broader-Perspective"><a href="#A-Broader-Perspective" class="headerlink" title="A Broader Perspective"></a>A Broader Perspective</h2><p>So why does the above code work? That requires a little bit of knowledge about the rendering process.</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>A component’s <code>render</code> function returns a tree of React elements, also known as the virtual DOM. This data structure is a representation of the browser’s DOM that React can manipulate in a performant way. In essence, it’s a 1-1 mapping to the browser DOM.</p>
<p>Whenever state or props change, instead of updating the browser DOM directly, React will call the <code>render</code> function of the updated component, getting its new virtual DOM, and it will compare that virtual DOM to the previous render tree (aka the old virtual DOM). This comparison process (known as reconciliation) allows it to identify the minimum set of changes that need to be made to the browser DOM, allowing for for massive performance gains. If the two trees are identical, then no changes need to be made to the UI.</p>
<h2 id="Should-a-Component-Re-render"><a href="#Should-a-Component-Re-render" class="headerlink" title="Should a Component Re-render"></a>Should a Component Re-render</h2><p>When <code>setState</code> is called on a component, that component (and all of the components it renders) go through a two step process for React determine if the UI should update.</p>
<p>Before the virtual DOM is rendered, React first runs a component’s <a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">shouldComponentUpdate</a> lifecycle method</p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>It is your choice to implement this method. It takes as parameters the new state and props and should return a boolean indicating whether the component should re-render. React will only proceed with re-rendering if you return <code>true</code> from this function. By default, <code>shouldComponentUpdate</code> always returns <code>true</code>.</p>
<p>Let’s look at a simple example</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>() </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      counter: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">    <span class="comment">// We are comparing the state before setState</span></div><div class="line">    <span class="comment">// is called to the state after it is called.</span></div><div class="line">    <span class="comment">// This component will only re-render if</span></div><div class="line">    <span class="comment">// state.counter changes</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.counter !== nextState.counter</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;span&gt;&#123;this.state.counter&#125;&lt;/span&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Currently <code>Counter</code> will only re-render if <code>state.counter</code> changes. Suppose we remove the <code>shouldComponentUpdate</code> above, is there another circumstance where <code>Counter</code>‘ re-renders? It would re-render if a component that renders <code>Counter</code> re-renders! It does not matter that <code>Counter</code>‘s render function does not depend on props!</p>
<p>So, when <code>shouldComponentUpdate</code> returns <code>true</code>, React begins the second part of the re-render process, the part where it invokes the render function, generating its virtual DOM. It will then compare that render tree to the old virtual DOM. In the scenario above, these two trees will always be identical (after all, the component doesn’t even have a way to change state), and the entire operation will a be waste CPU cycles.</p>
<p>If <code>shouldComponentUpdate</code> returns <code>false</code>, we inform React that a re-render will not be necessary, sparing it an unnecessary to call a component’s render function and the comparison of the render trees.</p>
<h2 id="React-pureComponent"><a href="#React-pureComponent" class="headerlink" title="React.pureComponent"></a>React.pureComponent</h2><p>Writing <code>shouldComponentUpdate</code> is sometimes a tedious task, and React supplies a helper to handle a very common <code>shouldComponentUpdate</code> scenario. I mentioned <code>React.pureComponent</code> above.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p><code>React.pureComponent</code> is a handy class that we can inherit from that implements <code>shouldComponentUpdate</code> as a shallow comparison across the old props and new props (or the old state and new state). If there are no <em>shallow</em> differences between these objects, then <code>shouldComponentUpdate</code> will return false, and the virtual DOM’s re-rendering process can be skipped entirely, resulting in potentially enormous performance savings.</p>
<h2 id="Why-Does-Immutability-Matter"><a href="#Why-Does-Immutability-Matter" class="headerlink" title="Why Does Immutability Matter?"></a>Why Does Immutability Matter?</h2><p>Immutability matters because <code>React.pureComponent</code> is going to do shallow comparisons against the prop and state objects. And, as you hopefully know, a shallow comparison’s referential equality checks will only yield the expected results if immutability is respected.</p>
<p>If you are not properly respecting immutability, then you are going to run into scenarios where your components fail to re-render when they actually should. A failure to respect immutability will cause a shallow comparison to return false (meaning <code>shouldComponentUpdate</code> returns false) because the old props and new props (or the old state and new state) reference the same object in memory, despite the fact that props/state changed.</p>
<p>When used carefully however, <code>React.pureComponent</code> can yield enormous performance improvements at almost no cost. All you need to do is inherit your components from <code>React.pureComponent</code> instead of <code>React.Component</code> and respect immutability when changing state.</p>
<p>I hope you found this article helpful. Please feel free to email me to reach out if you have questions.</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:nickdrane.com">
  </form>
</div>

  
  <div class="widget tag about">
    <ul class="entry">
      <div>
        <img class="about-photo" src="/images/about-photo.jpg" alt="photo of Nick Drane"/>
      </div>
      <p class="about-photo-text"> Nick Drane's blog about programming, hacking, software, computer security, and compute science.</p>

    </ul>
  </div>
  




  
<div class="widget tag recent-posts">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/scraping-the-web-with-puppeteer-lessons-learned/">Scraping the Web With Puppeteer: Lessons-learned</a>
      </li>
    
      <li>
        <a href="/build-your-own-regex/">Build a Regex Engine in Less than 40 Lines of Code</a>
      </li>
    
      <li>
        <a href="/write-your-own-redux-connect/">Write Your Own React-Redux Connect</a>
      </li>
    
      <li>
        <a href="/using-reduce/">Using Reduce</a>
      </li>
    
      <li>
        <a href="/leveraging-immutability-in-react/">Leveraging Immutability in React</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag category">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Functional-Programming/">Functional Programming</a><small>1</small></li>
  
    <li><a href="/categories/Immutability/">Immutability</a><small>1</small></li>
  
    <li><a href="/categories/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/categories/React/">React</a><small>2</small></li>
  
    <li><a href="/categories/Recursion/">Recursion</a><small>1</small></li>
  
    <li><a href="/categories/Redux/">Redux</a><small>1</small></li>
  
    <li><a href="/categories/Regular-Expressions/">Regular Expressions</a><small>1</small></li>
  
    <li><a href="/categories/Web-Scraping/">Web Scraping</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Nick Drane
  
</div>
<div class="clearfix"></div></footer>
  

</body>
</html>

